<!-- Standalone Generated By Octo (octo-ide.com) -->
<script>data={"program":"\n:alias pass_value v0\n:alias left_digit v1\n:alias right_digit v2\n:alias old_digit v1\n:alias new_digit v2\n:alias ticks_since_last_frame v9\n:alias carry_column va\n:alias no_erase_flag vb\n:alias tile_size vc\n:alias iterator vc\n:alias px vd\n:alias py ve\n\n:const stride 4\n:const numwidth 10\n:const numwidth_minus_one 9\n\n:const line_y 24\n:const time_x 1\n:const time_y 26\n:const young_label_x 12\n:const young_label_y 27\n:const bignum_x 24\n:const bignum_y 26\n\n: draw_bignum\n    px := bignum_x\n    py := bignum_y\n    iterator := 0\n\n    loop\n        # load old digit\n        i := old_result\n        i += iterator\n        load v0\n        old_digit := v0\n\n        # load new_digit\n        i := result\n        i += iterator\n        load v0\n        new_digit := v0\n\n\n        # if flag is non-zero we only draw the new digit and don't check if we should erase\n        if no_erase_flag != 0 begin\n            # draw new digit\n            pass_value := new_digit\n            :call 3_by_5_font_i\n            sprite px py 5\n        else\n            # only update digit if we need to\n            if old_digit != new_digit begin\n                # erase old digit\n                pass_value := old_digit\n                :call 3_by_5_font_i\n                sprite px py 5\n                # draw new digit\n                pass_value := new_digit\n                :call 3_by_5_font_i\n                sprite px py 5\n            end\n        end\n\n        # move over to next digit\n        px += stride\n\n        # increment iterator and go again if not finished\n        iterator += 1\n        if iterator != numwidth begin\n            again\n        end\n\nreturn\n\n\n: sub_bignum\n    iterator := numwidth_minus_one\n    carry_column := 0\n\n    loop\n        # load digit for left operand\n        i := left_operand\n        i += iterator\n        load v0\n        left_digit := v0\n\n        # load digit for right operand\n        i := right_operand\n        i += iterator\n        load v0\n        right_digit := v0\n\n        # set i to point to current column of result\n        i := result\n        i += iterator\n\n        # sub digits and carry column together\n        left_digit -= right_digit\n        left_digit -= carry_column\n\n        # sort out carry by adding to carry column until the current column is\n        # under 0 (>= 255 after underflow)\n        carry_column := 0\n        if left_digit >= 246 begin\n            loop\n                carry_column += 1\n                left_digit += 10\n                if left_digit >= 246 begin\n                    again\n                end\n        end\n\n        # save digit to result\n        v0 := left_digit\n        save v0\n\n        # prevent underflow by flooring at all zeroes if we would carry on the first column\n        if iterator == 0 begin\n            if carry_column > 0 begin\n                i := min_bignum\n                load v9\n                i := result\n                save v9\n            end\n        end\n\n        # check if we're finished\n        if iterator != 0 begin\n            iterator -= 1\n            again\n        end\nreturn\n\n\n: add_bignum\n    iterator := numwidth_minus_one\n    carry_column := 0\n\n    loop\n        # load digit for left operand\n        i := left_operand\n        i += iterator\n        load v0\n        left_digit := v0\n\n        # load digit for right operand\n        i := right_operand\n        i += iterator\n        load v0\n        right_digit := v0\n\n        # set i to point to current column of result\n        i := result\n        i += iterator\n\n        # add digits and carry column together\n        left_digit += right_digit\n        left_digit += carry_column\n\n        # sort out carry by adding to carry column until the current column is under 10\n        carry_column := 0\n        if left_digit > 9 begin\n            loop\n                carry_column += 1\n                left_digit -= 10\n                if left_digit > 9 begin\n                    again\n                end\n        end\n\n        # save digit to result\n        v0 := left_digit\n        save v0\n\n        # prevent overflow by capping at all nines if we would carry on the first column\n        if iterator == 0 begin\n            if carry_column > 0 begin\n                i := max_bignum\n                load v9\n                i := result\n                save v9\n            end\n        end\n\n        # check if we're finished\n        if iterator != 0 begin\n            iterator -= 1\n            again\n        end\nreturn\n\n\n: hex_font_i\n    i := hex v0\nreturn\n\n: 3_by_3_font_i\n    i := 3_by_3_font_index\n    i += pass_value\n    load v0\n    i := 3_by_3_font\n    i += v0\nreturn\n\n: 3_by_3_font_index\n    0 3 6 9 12 15 18 21 24 27\n\n: 3_by_3_font\n    0xE0 0xA0 0xE0 #zero\n    0xC0 0x40 0xE0 #one\n    0xC0 0x40 0x60 #two\n    0xE0 0x60 0xE0 #three\n    0xA0 0xE0 0x20 #four\n    0x60 0x40 0xC0 #five\n    0x80 0xE0 0xE0 #six\n    0xE0 0x20 0x20 #seven\n    0x60 0xE0 0xE0 #eight\n    0xE0 0xE0 0x20 #nine\n\n: 3_by_5_font_i\n    i := 3_by_5_font_index\n    i += pass_value\n    load v0\n    i := 3_by_5_font\n    i += v0\nreturn\n\n: 3_by_5_font_index\n    0 5 10 15 20 25 30 35 40 45\n\n: 3_by_5_font\n    0xE0 0xA0 0xA0 0xA0 0xE0 #zero\n    0xC0 0x40 0x40 0x40 0xE0 #one\n    0xE0 0x20 0xE0 0x80 0xE0 #two\n    0xE0 0x20 0xE0 0x20 0xE0 #three\n    0xA0 0xA0 0xE0 0x20 0x20 #four\n    0xE0 0x80 0xE0 0x20 0xE0 #five\n    0xE0 0x80 0xE0 0xA0 0xE0 #six\n    0xE0 0xA0 0x20 0x40 0x40 #seven\n    0xE0 0xA0 0xE0 0xA0 0xE0 #eight\n    0xE0 0xA0 0xE0 0x20 0xE0 #nine\n\n: tick_count\n    0\n: min_bignum\n    0 0 0 0 0 0 0 0 0 0\n: max_bignum\n    9 9 9 9 9 9 9 9 9 9\n: left_operand\n    0 0 0 0 0 0 0 0 0 0\n: right_operand\n    0 0 0 0 0 0 0 0 0 0\n: old_result\n    0 0 0 0 0 0 0 0 0 0\n: result\n    0 0 0 0 0 0 0 0 0 0\n: bcd_smallnum\n    0 0 0\n\n: min_smallnum\n    0\n: max_smallnum\n    99\n\n: button_cooldowns\n    0 0 0 0 0 0 # These are in order of Q W E A S D\n\n# The data in each count block acts as kind of a struct for tese aliases\n:alias current_count v0\n:alias old_count v1\n:alias display_flag v2\n:alias sprite_x v3\n:alias sprite_y v4\n:alias count_x v5\n:alias count_y v6\n:alias max_resource v7\n\n: count_emerson\n    01 00 00 01 01 12 04 42\n: sprite_emerson\n    0xDF 0x95 0xD5 0x95 0xD1 0x00 0xDB 0x95 0x95 0xB5\n: count_lake\n    01 00 00 23 01 33 04 23\n: sprite_lake\n    0x80 0x80 0x80 0x80 0xE0 0x09 0x0A 0x0C 0x0A 0x09\n: count_palmer\n    00 00 00 45 01 55 04 16\n: sprite_palmer\n    0xE8 0xA8 0xE8 0x88 0x8E 0x00 0xF3 0xAA 0xAA 0x8A\n: count_crosby\n    00 00 00 01 13 12 16 15\n: sprite_crosby\n    0xEE 0x89 0x8E 0xE9 0x00 0xEE 0x89 0xEE 0x29 0xEE\n: count_stills\n    00 00 00 23 13 33 16 8\n: sprite_stills\n    0xEE 0x84 0xE4 0x24 0xE0 0x0E 0x88 0x8E 0x82 0xEE\n: count_nash\n    00 00 00 45 13 55 16 99\n: sprite_nash\n    0x62 0x52 0x4A 0x46 0x00 0xE9 0x89 0xEF 0x29 0xE9\n: sprite_young_y\n    0xA0 0xE0 0x40 0x40\n: sprite_young_n\n    0x60 0xA0 0xA0 0xA0\n: sprite_young_g\n    0xC0 0x80 0xA0 0xE0\n: sprite_time_t\n    0xE0 0x40 0x40 0x40\n: sprite_line\n    0xFF\n\n: draw_resource\n    # check if we should initialize resource\n    if display_flag == 0 begin\n        if current_count > 0 begin\n            # draw marker sprite\n            sprite v3 v4 10\n            display_flag := 1\n            # draw first count\n            v8 := current_count\n            old_count := current_count\n            px := count_x\n            py := count_y\n            :call draw_smallnum\n            # save new data\n            current_count := v8\n            old_count := v8\n            return\n        end\n    end\n\n    # check if we should update the number\n    if current_count != old_count begin\n        # save current count so it doesn't get stomped\n        v8 := current_count\n        # erase old count\n        px := count_x\n        py := count_y\n        :call draw_smallnum\n        # draw new count\n        v1 := v8\n        px := count_x\n        py := count_y\n        :call draw_smallnum\n        # save new data\n        current_count := v8\n        old_count := v8\n    end\nreturn\n\n: draw_smallnum\n    i := bcd_smallnum\n    bcd v1\n    load v0\n    load v0\n    :call 3_by_5_font_i\n    sprite px py 5\n    px += stride\n    i := bcd_smallnum\n    v1 := 2\n    i += v1\n    load v0\n    :call 3_by_5_font_i\n    sprite px py 5\nreturn\n\n: draw_fullscreen_tiles\n    py := 0\n    tile_size := 8\n    loop\n        :call draw_fullscreen_tile_row\n        py += tile_size\n        if py < 32 begin\n            again\n        end\nreturn\n\n: draw_fullscreen_tile_row\n    px := 0\n    loop\n        sprite px py 8\n        px += 8\n        i += tile_size\n        if px < 64 begin\n            again\n        end\nreturn\n\n\n: title_screen\n    # display title screen\n    i := sprite_title_screen\n    :call draw_fullscreen_tiles\n\n    # wait for any key press\n    va := OCTO_KEY_W\n    vb := 30\n    i := sprite_title_exclamation\n    px := 60\n    py := 2\n    loop\n        # check for key press\n        if va key begin\n            # erase the screen\n            clear\n            return\n        end\n        # blink exclamation point on delay if no key press\n        v0 := delay\n        if v0 == 0 begin\n            delay := vb\n            sprite px py 8\n        end\n        again\nreturn\n\n\n: sprite_title_screen\n    0xFF 0x80 0x80 0x80 0x80 0x87 0x8C 0x98 0xFF 0x00 0x00 0x00 0x00 0x80 0xC0 0x40 0xFF 0x00 0x00 0x40 0x40 0x40 0x40 0x40 0xFE 0x03 0x01 0x00 0x00 0x00 0x04 0x04\n    0x7F 0xC0 0x80 0x00 0x00 0x20 0x20 0x20 0xFF 0x00 0x00 0x00 0x00 0x00 0x38 0x28 0xFF 0x80 0xA8 0xBA 0xAA 0x80 0x84 0xC5 0xFF 0x01 0xED 0x4D 0x4D 0x0D 0x4D 0x41\n    0x90 0x90 0x90 0x99 0x8F 0x80 0xC0 0x60 0x54 0x5C 0xDD 0x97 0x00 0x00 0x00 0x00 0x40 0x68 0x2C 0x26 0x23 0x21 0x01 0x05 0x84 0x87 0x9E 0x82 0x82 0x02 0x02 0x02\n    0x6C 0xEE 0x3A 0x33 0x11 0x11 0x10 0x00 0x38 0xF0 0x21 0x2F 0x38 0xC0 0x00 0x00 0x62 0x38 0x0F 0x00 0x00 0x00 0x00 0x00 0x8D 0x0D 0x81 0xFF 0x01 0x01 0x03 0x06\n    0x60 0xC0 0x80 0x80 0x9E 0x92 0x96 0x9E 0x00 0x00 0x00 0x00 0x6E 0xAA 0xEE 0x00 0x07 0x00 0x20 0x20 0xE0 0xA0 0xA0 0xE1 0x00 0x00 0x00 0x00 0x20 0x20 0x2B 0xE2\n    0x00 0x00 0x08 0x0C 0x06 0x03 0x81 0x80 0x00 0x23 0x25 0x25 0x65 0x45 0xC0 0xBA 0x00 0x6E 0x44 0x64 0x44 0x6E 0x00 0xBB 0x06 0x83 0x81 0x81 0x81 0xE1 0x01 0x81\n    0x82 0x82 0x92 0x9E 0x80 0x80 0x80 0xFF 0x00 0x00 0x00 0x00 0x00 0x00 0x00 0xFF 0x01 0x01 0x01 0x01 0x00 0x00 0x00 0xFF 0x2B 0x2A 0x2B 0xE0 0x00 0x01 0x03 0xFE\n    0x80 0x10 0xF0 0x00 0x00 0x80 0xC0 0x7F 0xAA 0xAA 0xAA 0xBB 0x00 0x00 0x00 0xFF 0xAA 0xAA 0xAA 0xAB 0x00 0x00 0x00 0xFF 0x01 0xC1 0x41 0xC1 0x01 0x01 0x01 0xFF\n\n: sprite_title_exclamation\n    0xC0 0xC0 0xC0 0xC0 0xC0 0x00 0xC0 0xC0\n\n: main\n    :call title_screen\n\n    # increase the cooldown for the W key so it doesn't cause problems by\n    # having been pressed on the title screen\n    i := button_cooldowns\n    v1 := 10\n    save v5\n\n    # initialize delay\n    v0 := 255\n    delay := v0\n\n    # Initialize score to 000\n    i := result\n    no_erase_flag := 1\n    :call draw_bignum\n    no_erase_flag := 0\n\n    # initialize resource counts\n    i := count_emerson\n    load v7\n    :call draw_resource\n    i := count_emerson\n    save v7\n\n    i := count_lake\n    load v7\n    :call draw_resource\n    i := count_lake\n    save v7\n\n    i := count_palmer\n    load v7\n    :call draw_resource\n    i := count_palmer\n    save v7\n\n    i := count_crosby\n    load v7\n    :call draw_resource\n    i := count_crosby\n    save v7\n\n\n    i := count_stills\n    load v7\n    :call draw_resource\n    i := count_stills\n    save v7\n\n    i := count_nash\n    load v7\n    :call draw_resource\n    i := count_nash\n    save v7\n\n    # draw line\n    px := 0\n    py := line_y\n    i := sprite_line\n    loop\n        sprite px py 1\n        px += 8\n        if px != 64 begin\n            again\n        end\n\n    #initialize time\n    v1 := 88\n    px := time_x\n    py := time_y\n    :call draw_smallnum\n\n    # draw the sprite for young count\n    px := young_label_x\n    py := young_label_y\n    i := sprite_young_y\n    sprite px py 4\n    px += 4\n    i := sprite_young_n\n    sprite px py 4\n    px += 4\n    i := sprite_young_g\n    sprite px py 4\n\n\n    loop\n        # subtract delay\n        ticks_since_last_frame := 255\n        v1 := delay\n        delay := ticks_since_last_frame #reset delay timer using 255\n        ticks_since_last_frame -= v1\n\n        # process key cooldowns\n        i := button_cooldowns\n        load v5\n\n        v0 -= ticks_since_last_frame\n        if vf == 0 then v0 := 0\n        v1 -= ticks_since_last_frame\n        if vf == 0 then v1 := 0\n        v2 -= ticks_since_last_frame\n        if vf == 0 then v2 := 0\n        v3 -= ticks_since_last_frame\n        if vf == 0 then v3 := 0\n        v4 -= ticks_since_last_frame\n        if vf == 0 then v4 := 0\n        v5 -= ticks_since_last_frame\n        if vf == 0 then v5 := 0\n\n        i := button_cooldowns\n        save v5\n\n        # process crosby\n        if v0 == 0 begin\n            vf := OCTO_KEY_Q\n            if vf key begin\n                # increment resource\n                i := count_emerson\n                load v7\n                current_count += 1\n                if current_count > max_resource begin\n                    current_count := max_resource\n                end\n                :call draw_resource\n                i := count_emerson\n                save v7\n\n                # update cooldown\n                i := button_cooldowns\n                load v5\n                v0 := 5\n                i := button_cooldowns\n                save v5\n            end\n        end\n\n        # process stills\n        if v1 == 0 begin\n            vf := OCTO_KEY_W\n            if vf key begin\n                # make sure user has enough resources\n                i := count_emerson\n                load v7\n                if current_count > 11 begin\n                    # update spent resource count\n                    current_count -= 12\n\n                    #update max resource for spent resource\n                    max_resource += 4\n                    if max_resource > 99 then max_resource := 99\n\n                    # draw spent resource\n                    :call draw_resource\n                    i := count_emerson\n                    save v7\n\n                    # add to new resource\n                    i := count_lake\n                    load v7\n                    current_count += 1\n                    if current_count > max_resource begin\n                        current_count := max_resource\n                    end\n\n                    # save current state of resource\n                    :call draw_resource\n                    i := count_lake\n                    save v7\n\n                    # check if we should enable next resource\n                    if max_resource < 24 begin\n                        if current_count > 6 begin\n                            i := count_palmer\n                            load v7\n                            current_count := 1\n                            :call draw_resource\n                            i := count_palmer\n                            save v7\n                        end\n                    end\n\n                    # update cooldown\n                    i := button_cooldowns\n                    load v5\n                    v1 := 5\n                    i := button_cooldowns\n                    save v5\n                end\n            end\n        end\n\n        # store result as left operand\n        # we have to do some register dancing here to avoid clobbering the delay global\n        # this probably won't be necessary in the final version because everything for\n        # the bignum will be calculated from the resource counts and not the actual delay\n        # value\n        va := ticks_since_last_frame\n        i := result\n        load v9\n        i := left_operand\n        save v9\n        ticks_since_last_frame := va\n\n\n        # save delay difference as right operand\n        v1 := 7\n        i := right_operand\n        i += v1\n        bcd ticks_since_last_frame\n\n        # add timer\n        :call add_bignum\n\n        # display new result\n        :call draw_bignum\n\n\n        # copy result to old_result\n        i := result\n        load v9\n        i := old_result\n        save v9\n\n        again\n","options":{"tickrate":10000,"fillColor":"#3D8026","fillColor2":"#ABCC47","blendColor":"#00131A","backgroundColor":"#F9FFB3","buzzColor":"#F9FFB3","quietColor":"#000000","shiftQuirks":false,"loadStoreQuirks":false,"vfOrderQuirks":false,"clipQuirks":false,"vBlankQuirks":false,"jumpQuirks":false,"screenRotation":0,"maxSize":3584,"touchInputMode":"None","logicQuirks":false,"fontStyle":"octo"},"rom":[21,219,109,24,110,26,108,0,163,149,252,30,240,101,129,0,163,159,252,30,240,101,130,0,75,0,18,36,128,32,35,36,221,229,18,52,145,32,18,52,128,16,35,36,221,229,128,32,35,36,221,229,125,4,124,1,76,10,18,62,18,8,0,238,108,9,106,0,163,129,252,30,240,101,129,0,163,139,252,30,240,101,130,0,163,159,252,30,129,37,129,165,106,0,111,246,143,23,79,0,18,116,122,1,113,10,111,246,143,23,79,0,18,116,18,102,128,16,240,85,60,0,18,140,111,0,143,165,63,0,18,140,163,109,249,101,163,159,249,85,76,0,18,148,124,255,18,68,0,238,108,9,106,0,163,129,252,30,240,101,129,0,163,139,252,30,240,101,130,0,163,159,252,30,129,36,129,164,106,0,111,9,143,21,63,0,18,202,122,1,113,246,111,9,143,21,63,0,18,202,18,188,128,16,240,85,60,0,18,226,111,0,143,165,63,0,18,226,163,119,249,101,163,159,249,85,76,0,18,234,124,255,18,154,0,238,240,41,0,238,162,252,240,30,240,101,163,6,240,30,0,238,0,3,6,9,12,15,18,21,24,27,224,160,224,192,64,224,192,64,96,224,96,224,160,224,32,96,64,192,128,224,224,224,32,32,96,224,224,224,224,32,163,48,240,30,240,101,163,58,240,30,0,238,0,5,10,15,20,25,30,35,40,45,224,160,160,160,224,192,64,64,64,224,224,32,224,128,224,224,32,224,32,224,160,160,224,32,32,224,128,224,32,224,224,128,224,160,224,224,160,32,64,64,224,160,224,160,224,224,160,224,32,224,0,0,0,0,0,0,0,0,0,0,0,9,9,9,9,9,9,9,9,9,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,99,0,0,0,0,0,0,1,0,0,1,1,12,4,42,223,149,213,149,209,0,219,149,149,181,1,0,0,23,1,33,4,23,128,128,128,128,224,9,10,12,10,9,0,0,0,45,1,55,4,16,232,168,232,136,142,0,243,170,170,138,0,0,0,1,13,12,16,15,238,137,142,233,0,238,137,238,41,238,0,0,0,23,13,33,16,8,238,132,228,36,224,14,136,142,130,238,0,0,0,45,13,55,16,99,98,82,74,70,0,233,137,239,41,233,160,224,64,64,96,160,160,160,192,128,160,224,224,64,64,64,255,50,0,20,81,111,0,143,5,63,0,20,81,211,74,98,1,136,0,129,0,141,80,142,96,36,107,128,128,129,128,0,238,144,16,20,105,136,0,141,80,142,96,36,107,129,128,141,80,142,96,36,107,128,128,129,128,0,238,163,169,241,51,240,101,240,101,35,36,221,229,125,4,163,169,97,2,241,30,240,101,35,36,221,229,0,238,110,0,108,8,36,155,142,196,111,32,143,231,63,0,20,153,20,139,0,238,109,0,221,232,125,8,252,30,111,64,143,215,63,0,20,173,20,157,0,238,164,211,36,135,106,5,107,30,165,211,109,60,110,2,234,158,20,197,0,224,0,238,240,7,48,0,20,207,251,21,221,232,20,189,0,238,255,128,128,128,128,135,140,152,255,0,0,0,0,128,192,64,255,0,0,64,64,64,64,64,254,3,1,0,0,0,4,4,127,192,128,0,0,32,32,32,255,0,0,0,0,0,56,40,255,128,168,186,170,128,132,197,255,1,237,77,77,13,77,65,144,144,144,153,143,128,192,96,84,92,221,151,0,0,0,0,64,104,44,38,35,33,1,5,132,135,158,130,130,2,2,2,108,238,58,51,17,17,16,0,56,240,33,47,56,192,0,0,98,56,15,0,0,0,0,0,141,13,129,255,1,1,3,6,96,192,128,128,158,146,150,158,0,0,0,0,110,170,238,0,7,0,32,32,224,160,160,225,0,0,0,0,32,32,43,226,0,0,8,12,6,3,129,128,0,35,37,37,101,69,192,186,0,110,68,100,68,110,0,187,6,131,129,129,129,225,1,129,130,130,146,158,128,128,128,255,0,0,0,0,0,0,0,255,1,1,1,1,0,0,0,255,43,42,43,224,0,1,3,254,128,16,240,0,0,128,192,127,170,170,170,187,0,0,0,255,170,170,170,171,0,0,0,255,1,193,65,193,1,1,1,255,192,192,192,192,192,0,192,192,36,175,163,174,97,10,245,85,96,255,240,21,163,159,107,1,34,2,107,0,163,180,247,101,36,49,163,180,247,85,163,198,247,101,36,49,163,198,247,85,163,216,247,101,36,49,163,216,247,85,163,234,247,101,36,49,163,234,247,85,163,252,247,101,36,49,163,252,247,85,164,14,247,101,36,49,164,14,247,85,109,0,110,24,164,48,221,225,125,8,77,64,22,59,22,49,97,88,109,1,110,26,36,107,109,12,110,27,164,32,221,228,125,4,164,36,221,228,125,4,164,40,221,228,105,255,241,7,249,21,137,21,163,174,245,101,128,149,79,0,96,0,129,149,79,0,97,0,130,149,79,0,98,0,131,149,79,0,99,0,132,149,79,0,100,0,133,149,79,0,101,0,163,174,245,85,48,0,22,181,111,4,239,158,22,181,163,180,247,101,112,1,143,112,143,5,63,0,22,165,128,112,36,49,163,180,247,85,163,174,245,101,96,5,163,174,245,85,49,0,23,25,111,5,239,158,23,25,163,180,247,101,111,11,143,5,63,0,23,25,112,244,119,4,111,99,143,117,79,0,103,99,36,49,163,180,247,85,163,198,247,101,112,1,143,112,143,5,63,0,22,237,128,112,36,49,163,198,247,85,111,24,143,119,63,0,23,15,111,6,143,5,63,0,23,15,163,216,247,101,96,1,36,49,163,216,247,85,163,174,245,101,97,5,163,174,245,85,138,144,163,159,249,101,163,129,249,85,137,160,97,7,163,139,241,30,249,51,34,150,34,2,163,159,249,101,163,149,249,85,22,87]}</script>
<script>"use strict";

function invertKeymap(k) {
	return Object.keys(k).reduce((a,b) => {
		Object.keys(k[b]).forEach(x => a[x]=+b)
		return a
	}, {})
}

function getPref(key) {
	try { return JSON.parse(localStorage.getItem(key)) }
	catch(e) { console.log(e); return null }
}
function setPref(key, value) {
	try { localStorage.setItem(key, JSON.stringify(value)) }
	catch(e) { console.log(e); }
}

var keymap = (this.STATIC_KEYMAP) || getPref('octoKeymap') || {
	0x0: { x:1 },
	0x1: { 1:1 },
	0x2: { 2:1 },
	0x3: { 3:1 },
	0x4: { q:1 },
	0x5: { w:1, ArrowUp:1 },
	0x6: { e:1, ' ':1 },
	0x7: { a:1, ArrowLeft:1 },
	0x8: { s:1, ArrowDown:1 },
	0x9: { d:1, ArrowRight:1 },
	0xA: { z:1 },
	0xB: { c:1 },
	0xC: { 4:1 },
	0xD: { r:1 },
	0xE: { f:1 },
	0xF: { v:1 },
}

var keymapInverse = invertKeymap(keymap)

var smallfonts = {
	octo: [
		0xF0, 0x90, 0x90, 0x90, 0xF0, // 0
		0x20, 0x60, 0x20, 0x20, 0x70, // 1
		0xF0, 0x10, 0xF0, 0x80, 0xF0, // 2
		0xF0, 0x10, 0xF0, 0x10, 0xF0, // 3
		0x90, 0x90, 0xF0, 0x10, 0x10, // 4
		0xF0, 0x80, 0xF0, 0x10, 0xF0, // 5
		0xF0, 0x80, 0xF0, 0x90, 0xF0, // 6
		0xF0, 0x10, 0x20, 0x40, 0x40, // 7
		0xF0, 0x90, 0xF0, 0x90, 0xF0, // 8
		0xF0, 0x90, 0xF0, 0x10, 0xF0, // 9
		0xF0, 0x90, 0xF0, 0x90, 0x90, // A
		0xE0, 0x90, 0xE0, 0x90, 0xE0, // B
		0xF0, 0x80, 0x80, 0x80, 0xF0, // C
		0xE0, 0x90, 0x90, 0x90, 0xE0, // D
		0xF0, 0x80, 0xF0, 0x80, 0xF0, // E
		0xF0, 0x80, 0xF0, 0x80, 0x80, // F
	],
	vip: [
		0xF0, 0x90, 0x90, 0x90, 0xF0,
		0x60, 0x20, 0x20, 0x20, 0x70,
		0xF0, 0x10, 0xF0, 0x80, 0xF0,
		0xF0, 0x10, 0xF0, 0x10, 0xF0,
		0xA0, 0xA0, 0xF0, 0x20, 0x20,
		0xF0, 0x80, 0xF0, 0x10, 0xF0,
		0xF0, 0x80, 0xF0, 0x90, 0xF0,
		0xF0, 0x10, 0x10, 0x10, 0x10,
		0xF0, 0x90, 0xF0, 0x90, 0xF0,
		0xF0, 0x90, 0xF0, 0x10, 0xF0,
		0xF0, 0x90, 0xF0, 0x90, 0x90,
		0xF0, 0x50, 0x70, 0x50, 0xF0,
		0xF0, 0x80, 0x80, 0x80, 0xF0,
		0xF0, 0x50, 0x50, 0x50, 0xF0,
		0xF0, 0x80, 0xF0, 0x80, 0xF0,
		0xF0, 0x80, 0xF0, 0x80, 0x80,
	],
	dream6800: [
		0xE0, 0xA0, 0xA0, 0xA0, 0xE0,
		0x40, 0x40, 0x40, 0x40, 0x40,
		0xE0, 0x20, 0xE0, 0x80, 0xE0,
		0xE0, 0x20, 0xE0, 0x20, 0xE0,
		0x80, 0xA0, 0xA0, 0xE0, 0x20,
		0xE0, 0x80, 0xE0, 0x20, 0xE0,
		0xE0, 0x80, 0xE0, 0xA0, 0xE0,
		0xE0, 0x20, 0x20, 0x20, 0x20,
		0xE0, 0xA0, 0xE0, 0xA0, 0xE0,
		0xE0, 0xA0, 0xE0, 0x20, 0xE0,
		0xE0, 0xA0, 0xE0, 0xA0, 0xA0,
		0xC0, 0xA0, 0xE0, 0xA0, 0xC0,
		0xE0, 0x80, 0x80, 0x80, 0xE0,
		0xC0, 0xA0, 0xA0, 0xA0, 0xC0,
		0xE0, 0x80, 0xE0, 0x80, 0xE0,
		0xE0, 0x80, 0xC0, 0x80, 0x80,
	],
	eti660: [
		0xE0, 0xA0, 0xA0, 0xA0, 0xE0,
		0x20, 0x20, 0x20, 0x20, 0x20,
		0xE0, 0x20, 0xE0, 0x80, 0xE0,
		0xE0, 0x20, 0xE0, 0x20, 0xE0,
		0xA0, 0xA0, 0xE0, 0x20, 0x20,
		0xE0, 0x80, 0xE0, 0x20, 0xE0,
		0xE0, 0x80, 0xE0, 0xA0, 0xE0,
		0xE0, 0x20, 0x20, 0x20, 0x20,
		0xE0, 0xA0, 0xE0, 0xA0, 0xE0,
		0xE0, 0xA0, 0xE0, 0x20, 0xE0,
		0xE0, 0xA0, 0xE0, 0xA0, 0xA0,
		0x80, 0x80, 0xE0, 0xA0, 0xE0,
		0xE0, 0x80, 0x80, 0x80, 0xE0,
		0x20, 0x20, 0xE0, 0xA0, 0xE0,
		0xE0, 0x80, 0xE0, 0x80, 0xE0,
		0xE0, 0x80, 0xC0, 0x80, 0x80,
	],
	fish: [
		0x60, 0xA0, 0xA0, 0xA0, 0xC0,
		0x40, 0xC0, 0x40, 0x40, 0xE0,
		0xC0, 0x20, 0x40, 0x80, 0xE0,
		0xC0, 0x20, 0x40, 0x20, 0xC0,
		0x20, 0xA0, 0xE0, 0x20, 0x20,
		0xE0, 0x80, 0xC0, 0x20, 0xC0,
		0x40, 0x80, 0xC0, 0xA0, 0x40,
		0xE0, 0x20, 0x60, 0x40, 0x40,
		0x40, 0xA0, 0x40, 0xA0, 0x40,
		0x40, 0xA0, 0x60, 0x20, 0x40,
		0x40, 0xA0, 0xE0, 0xA0, 0xA0,
		0xC0, 0xA0, 0xC0, 0xA0, 0xC0,
		0x60, 0x80, 0x80, 0x80, 0x60,
		0xC0, 0xA0, 0xA0, 0xA0, 0xC0,
		0xE0, 0x80, 0xC0, 0x80, 0xE0,
		0xE0, 0x80, 0xC0, 0x80, 0x80,
	],
}
var bigfonts = {
	octo: [
		0xFF, 0xFF, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, // 0
		0x18, 0x78, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0xFF, // 1
		0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, // 2
		0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 3
		0xC3, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, 0x03, 0x03, 0x03, 0x03, // 4
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 5
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, // 6
		0xFF, 0xFF, 0x03, 0x03, 0x06, 0x0C, 0x18, 0x18, 0x18, 0x18, // 7
		0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, // 8
		0xFF, 0xFF, 0xC3, 0xC3, 0xFF, 0xFF, 0x03, 0x03, 0xFF, 0xFF, // 9
		0x7E, 0xFF, 0xC3, 0xC3, 0xC3, 0xFF, 0xFF, 0xC3, 0xC3, 0xC3, // A
		0xFC, 0xFC, 0xC3, 0xC3, 0xFC, 0xFC, 0xC3, 0xC3, 0xFC, 0xFC, // B
		0x3C, 0xFF, 0xC3, 0xC0, 0xC0, 0xC0, 0xC0, 0xC3, 0xFF, 0x3C, // C
		0xFC, 0xFE, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xFE, 0xFC, // D
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, // E
		0xFF, 0xFF, 0xC0, 0xC0, 0xFF, 0xFF, 0xC0, 0xC0, 0xC0, 0xC0  // F
	],
	schip: [
		0x3C, 0x7E, 0xE7, 0xC3, 0xC3, 0xC3, 0xC3, 0xE7, 0x7E, 0x3C,
		0x18, 0x38, 0x58, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C,
		0x3E, 0x7F, 0xC3, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xFF, 0xFF,
		0x3C, 0x7E, 0xC3, 0x03, 0x0E, 0x0E, 0x03, 0xC3, 0x7E, 0x3C,
		0x06, 0x0E, 0x1E, 0x36, 0x66, 0xC6, 0xFF, 0xFF, 0x06, 0x06,
		0xFF, 0xFF, 0xC0, 0xC0, 0xFC, 0xFE, 0x03, 0xC3, 0x7E, 0x3C,
		0x3E, 0x7C, 0xE0, 0xC0, 0xFC, 0xFE, 0xC3, 0xC3, 0x7E, 0x3C,
		0xFF, 0xFF, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x60, 0x60,
		0x3C, 0x7E, 0xC3, 0xC3, 0x7E, 0x7E, 0xC3, 0xC3, 0x7E, 0x3C,
		0x3C, 0x7E, 0xC3, 0xC3, 0x7F, 0x3F, 0x03, 0x03, 0x3E, 0x7C,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // no hex chars!
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	],
	fish: [
		0x7C, 0xC6, 0xCE, 0xDE, 0xD6, 0xF6, 0xE6, 0xC6, 0x7C, 0x00, // at most 7x9 pixels!
		0x10, 0x30, 0xF0, 0x30, 0x30, 0x30, 0x30, 0x30, 0xFC, 0x00,
		0x78, 0xCC, 0xCC, 0x0C, 0x18, 0x30, 0x60, 0xCC, 0xFC, 0x00,
		0x78, 0xCC, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0xCC, 0x78, 0x00,
		0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x1E, 0x00,
		0xFC, 0xC0, 0xC0, 0xC0, 0xF8, 0x0C, 0x0C, 0xCC, 0x78, 0x00,
		0x38, 0x60, 0xC0, 0xC0, 0xF8, 0xCC, 0xCC, 0xCC, 0x78, 0x00,
		0xFE, 0xC6, 0xC6, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00,
		0x78, 0xCC, 0xCC, 0xEC, 0x78, 0xDC, 0xCC, 0xCC, 0x78, 0x00,
		0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x18, 0x18, 0x30, 0x70, 0x00,
		0x30, 0x78, 0xCC, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0xCC, 0x00,
		0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0xFC, 0x00,
		0x3C, 0x66, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x66, 0x3C, 0x00,
		0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00,
		0xFE, 0x62, 0x60, 0x64, 0x7C, 0x64, 0x60, 0x62, 0xFE, 0x00,
		0xFE, 0x66, 0x62, 0x64, 0x7C, 0x64, 0x60, 0x60, 0xF0, 0x00,
	],
	none: new Array(16*10).fill(0x00),
}
var fontsets = {
	octo     : { small: smallfonts.octo,      big: bigfonts.octo  },
	vip      : { small: smallfonts.vip,       big: bigfonts.none  },
	dream6800: { small: smallfonts.dream6800, big: bigfonts.none  },
	eti660   : { small: smallfonts.eti660,    big: bigfonts.none  },
	schip    : { small: smallfonts.octo,      big: bigfonts.schip },
	fish     : { small: smallfonts.fish,      big: bigfonts.fish  },
}

////////////////////////////////////
//
//   The Chip8 Interpreter:
//
////////////////////////////////////

function Emulator() {

	// persistent configuration settings
	this.tickrate           = 20;
	this.fillColor          = "#FFCC00";
	this.fillColor2         = "#FF6600";
	this.blendColor         = "#662200";
	this.backgroundColor    = "#996600";
	this.buzzColor          = "#FFAA00";
	this.quietColor         = "#000000";
	this.shiftQuirks        = false;
	this.loadStoreQuirks    = false;
	this.vfOrderQuirks      = false;
	this.clipQuirks         = false;
	this.jumpQuirks         = false;
	this.logicQuirks        = false;
	this.vBlankQuirks       = false;
	this.enableXO           = true;
	this.screenRotation     = 0;//must be 0, 90, 180, or 270
	this.maxSize            = 3584;
	this.touchInputMode     = 'none';
	this.maskFormatOverride = true;
	this.numericFormatStr   = "default";
	this.fontStyle          = 'octo';

	// interpreter state
	this.p  = [[],[]];  // pixels
	this.m  = [];       // memory (bytes)
	this.r  = [];       // return stack
	this.v  = [];       // registers
	this.pc = 0;        // program counter
	this.i  = 0;        // index register
	this.dt = 0;        // delay timer
	this.st = 0;        // sound timer
	this.hires = false; // are we in SuperChip high res mode?
	this.flags = [];    // semi-persistent hp48 flag vars
	this.pattern = [];  // audio pattern buffer
	this.plane = 1;     // graphics plane
	this.profile_data = {};

	// control/debug state
	this.keys = {};       // track keys which are pressed
	this.waiting = false; // are we waiting for a keypress?
	this.waitReg = -1;    // destination register of an awaited key
	this.halted = true;
	this.breakpoint = false;
	this.metadata = {};
	this.tickCounter = 0;
	this.linted = false;

	// external interface stubs
	this.exitVector  = function() {}                                   // fired by 'exit'
	this.importFlags = function() { return [0, 0, 0, 0, 0, 0, 0, 0]; } // load persistent flags
	this.exportFlags = function(flags) {}                              // save persistent flags
	this.buzzTrigger = function(ticks, remainingTicks) {}                              // fired when buzzer played

	this.init = function(rom) {
		// initialise memory with a new array to ensure that it is of the right size and is initiliased to 0
		this.m = this.enableXO ? new Uint8Array(0x10000) : new Uint8Array(0x1000);

		this.p = [[], []];
		if (this.enableXO)
			for(var z = 0; z < 64*128; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
		else
			for(var z = 0; z < 32*64; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }

		// initialize memory
		var font = fontsets[this.fontStyle];
		for(var z = 0; z < 32*64;            z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
		for(var z = 0; z < font.small.length;z++) { this.m[z] = font.small[z]; }
		for(var z = 0; z < font.big.length;  z++) { this.m[z + font.small.length] = font.big[z]; }
		for(var z = 0; z < rom.rom.length;   z++) { this.m[0x200+z] = rom.rom[z]; }
		for(var z = 0; z < 16;               z++) { this.v[z] = 0; }
		for(var z = 0; z < 16;               z++) { this.pattern[z] = 0; }

		// initialize interpreter state
		this.r = [];
		this.pc = 0x200;
		this.i  = 0;
		this.dt = 0;
		this.st = 0;
		this.hires = false;
		this.plane = 1;

		// initialize control/debug state
		this.keys = {};
		this.waiting = false;
		this.waitReg = -1;
		this.halted = false;
		this.breakpoint = false;
		this.stack_breakpoint = -1;
		this.metadata = rom;
		this.tickCounter = 0;
		this.profile_data = {};
	}

	this.writeCarry = function(dest, value, flag) {
		this.v[dest] = (value & 0xFF);
		this.v[0xF] = flag ? 1 : 0;
		if (this.vfOrderQuirks) {
			this.v[dest] = (value & 0xFF);
		}
	}

	this.math = function(x, y, op) {
		// basic arithmetic opcodes
		switch(op) {
			case 0x0: this.v[x]  = this.v[y]; break;
			case 0x1: this.v[x] |= this.v[y]; if (this.logicQuirks) this.v[0xF]=0; break;
			case 0x2: this.v[x] &= this.v[y]; if (this.logicQuirks) this.v[0xF]=0; break;
			case 0x3: this.v[x] ^= this.v[y]; if (this.logicQuirks) this.v[0xF]=0; break;
			case 0x4:
				var t = this.v[x]+this.v[y];
				this.writeCarry(x, t, (t > 0xFF));
				break;
			case 0x5:
				var t = this.v[x]-this.v[y];
				this.writeCarry(x, t, (this.v[x] >= this.v[y]));
				break;
			case 0x7:
				var t = this.v[y]-this.v[x];
				this.writeCarry(x, t, (this.v[y] >= this.v[x]));
				break;
			case 0x6:
				if (this.shiftQuirks) { y = x; }
				var t = this.v[y] >> 1;
				this.writeCarry(x, t, (this.v[y] & 0x1));
				break;
			case 0xE:
				if (this.shiftQuirks) { y = x; }
				var t = this.v[y] << 1;
				this.writeCarry(x, t, ((this.v[y] >> 7) & 0x1));
				break;
			default:
				haltBreakpoint("unknown math opcode "+op.toString(16).toUppercase());
		}
	}

	this.misc = function(x, rest) {
		// miscellaneous opcodes
		switch(rest) {
			case 0x01:
				this.plane = (x & 0x3);
				break;
			case 0x02:
				for(var z = 0; z < 16; z++) {
					this.pattern[z] = this.m[this.i+z];
				}
				break;
			case 0x07: this.v[x] = this.dt; break;
			case 0x0A: this.waiting = true; this.waitReg = x; break;
			case 0x15: this.dt = this.v[x]; break;
			case 0x18: this.buzzTrigger(this.v[x], this.st); this.st = this.v[x]; break;
			case 0x1E: this.i = (this.i + this.v[x])&0xFFFF; break;
			case 0x29: this.i = ((this.v[x] & 0xF) * 5); break;
			case 0x30: this.i = ((this.v[x] & 0xF) * 10 + fontsets[this.fontStyle].small.length); break;
			case 0x33:
				this.m[this.i]   = Math.floor(this.v[x]/100)%10;
				this.m[this.i+1] = Math.floor(this.v[x]/10)%10;
				this.m[this.i+2] = this.v[x]%10;
				break;
			case 0x55:
				for(var z = 0; z <= x; z++) { this.m[this.i+z] = this.v[z]; }
				if (!this.loadStoreQuirks) { this.i = (this.i+x+1)&0xFFFF; }
				break;
			case 0x65:
				for(var z = 0; z <= x; z++) { this.v[z] = this.m[this.i+z]; }
				if (!this.loadStoreQuirks) { this.i = (this.i+x+1)&0xFFFF; }
				break;
			case 0x75:
				for(var z = 0; z <= x; z++) { this.flags[z] = this.v[z]; }
				this.exportFlags(this.flags);
				break;
			case 0x85:
				this.flags = this.importFlags();
				if (typeof this.flags == "undefined" || this.flags == null) {
					this.flags = [0, 0, 0, 0, 0, 0, 0, 0];
				}
				for(var z = 0; z <= x; z++) { this.v[z] = this.flags[z]; }
				break;
			default:
				haltBreakpoint("unknown misc opcode "+rest.toString(16).toUppercase());
		}
	}

	this.sprite = function sprite(x, y, len) {
		this.v[0xF] = 0x0;
		var rowSize = this.hires ? 128 : 64;
		var colSize = this.hires ?  64 : 32;
		var i = this.i;
		for(var layer = 0; layer < 2; layer++) {
			if ((this.plane & (layer+1)) == 0) { continue; }
			if (len == 0) {
				// draw a SuperChip 16x16 sprite
				for(var a = 0; a < 16; a++) {
					for(var b = 0; b < 16; b++) {
						var target = ((x+b) % rowSize) + ((y+a) % colSize)*rowSize;
						var source = ((this.m[i+(a*2)+(b > 7 ? 1:0)] >> (7-(b%8))) & 0x1) != 0;
						if (this.clipQuirks) {
							if ((x%rowSize)+b>=rowSize || (y%colSize)+a>=colSize) { source = 0; }
						}
						if (!source) { continue; }
						if (this.p[layer][target]) { this.p[layer][target] = 0; this.v[0xF] = 0x1; }
						else { this.p[layer][target] = 1; }
					}
				}
				i += 32;
			}
			else {
				// draw a Chip8 8xN sprite
				for(var a = 0; a < len; a++) {
					for(var b = 0; b < 8; b++) {
						var target = ((x+b) % rowSize) + ((y+a) % colSize)*rowSize;
						var source = ((this.m[i+a] >> (7-b)) & 0x1) != 0;
						if (this.clipQuirks) {
							if ((x%rowSize)+b>=rowSize || (y%colSize)+a>=colSize) { source = 0; }
						}
						if (!source) { continue; }
						if (this.p[layer][target]) { this.p[layer][target] = 0; this.v[0xF] = 0x1; }
						else { this.p[layer][target] = 1; }
					}
				}
				i += len;
			}
		}
	}

	this.call = function(nnn) {
		if (this.r.length >= 12) {
			haltBreakpoint("call stack overflow.");
		}
		this.r.push(this.pc);
		this.pc = nnn
	}

	this.jump0 = function(nnn) {
		if (this.jumpQuirks) { this.pc = nnn + this.v[(nnn >> 8)&0xF];  }
		else                 { this.pc = nnn + this.v[0]; }
	}

	this.machine = function(nnn) {
		if (nnn == 0x000) { this.halted = true; return; }
		haltBreakpoint("machine code is not supported.");
	}

	this.skip = function() {
		var op = (this.m[this.pc  ] << 8) | this.m[this.pc+1];
		this.pc += (op == 0xF000) ? 4 : 2;
	}

	this.opcode = function() {
		// Increment profilining data
		this.profile_data[this.pc] = (this.profile_data[this.pc] || 0) + 1;

		// decode the current opcode
		var op  = (this.m[this.pc  ] << 8) | this.m[this.pc+1];
		var o   = (this.m[this.pc  ] >> 4) & 0x00F;
		var x   = (this.m[this.pc  ]     ) & 0x00F;
		var y   = (this.m[this.pc+1] >> 4) & 0x00F;
		var n   = (this.m[this.pc+1]     ) & 0x00F;
		var nn  = (this.m[this.pc+1]     ) & 0x0FF;
		var nnn = op & 0xFFF;
		this.pc += 2;

		// execute a simple opcode
		if (op == 0x00E0) {
			// clear
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var z = 0; z < this.p[layer].length; z++) {
					this.p[layer][z] = 0;
				}
			}
			return;
		}
		if (op == 0x00EE) {
			// return
			this.pc = this.r.pop();
			return;
		}
		if ((op & 0xF0FF) == 0xE09E) {
			// if -key
			if (Object.keys(keymap[this.v[x]]||{}).some(x => x in this.keys)) { this.skip(); }
			return;
		}
		if ((op & 0xF0FF) == 0xE0A1) {
			// if key
			if (!Object.keys(keymap[this.v[x]]||{}).some(x => x in this.keys)) { this.skip(); }
			return;
		}
		if ((op & 0xFFF0) == 0x00C0) {
			// scroll down n pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var z = this.p[layer].length - 1; z >= 0; z--) {
					this.p[layer][z] = (z >= rowSize * n) ? this.p[layer][z - (rowSize * n)] : 0;
				}
			}
			return;
		}
		if ((op & 0xFFF0) == 0x00D0) {
			// scroll up n pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var z = 0; z < this.p[layer].length; z++) {
					this.p[layer][z] = (z < (this.p[layer].length - rowSize * n)) ? this.p[layer][z + (rowSize * n)] : 0;
				}
			}
			return;
		}
		if (op == 0x00FB) {
			// scroll right 4 pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var a = 0; a < this.p[layer].length; a += rowSize) {
					for(var b = rowSize-1; b >= 0; b--) {
						this.p[layer][a + b] = (b > 3) ? this.p[layer][a + b - 4] : 0;
					}
				}
			}
			return;
		}
		if (op == 0x00FC) {
			// scroll left 4 pixels
			var rowSize = this.hires ? 128 : 64;
			for(var layer = 0; layer < 2; layer++) {
				if ((this.plane & (layer+1)) == 0) { continue; }
				for(var a = 0; a < this.p[layer].length; a += rowSize) {
					for(var b = 0; b < rowSize; b++) {
						this.p[layer][a + b] = (b < rowSize - 4) ? this.p[layer][a + b + 4] : 0;
					}
				}
			}
			return;
		}
		if (op == 0x00FD) {
			// exit
			this.halted = true;
			this.exitVector();
			return;
		}
		if (op == 0x00FE) {
			// lores
			this.hires = false;
			this.p = [[], []];
			for(var z = 0; z < 32*64; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
			return;
		}
		if (op == 0x00FF) {
			// hires
			this.hires = true;
			this.p = [[], []];
			for(var z = 0; z < 64*128; z++) { this.p[0][z] = 0; this.p[1][z] = 0; }
			return;
		}
		if (op == 0xF000) {
			// long memory reference
			this.i = ((this.m[this.pc] << 8) | (this.m[this.pc+1])) & 0xFFFF;
			this.pc += 2;
			return;
		}

		if (o == 0x5 && n != 0) {
			if (n == 2) {
				// save range
				var dist = Math.abs(x - y);
				if (x < y) { for(var z = 0; z <= dist; z++) { this.m[this.i+z] = this.v[x+z]; }}
				else       { for(var z = 0; z <= dist; z++) { this.m[this.i+z] = this.v[x-z]; }}
				return;
			}
			else if (n == 3) {
				// load range
				var dist = Math.abs(x - y);
				if (x < y) { for(var z = 0; z <= dist; z++) { this.v[x+z] = this.m[this.i+z]; }}
				else       { for(var z = 0; z <= dist; z++) { this.v[x-z] = this.m[this.i+z]; }}
				return;
			}
			else {
				haltBreakpoint("unknown opcode "+op.toString(16).toUppercase());
			}
		}
		if (o == 0x9 && n != 0) {
			haltBreakpoint("unknown opcode "+op.toString(16).toUppercase());
		}

		// dispatch complex opcodes
		switch(o) {
			case 0x0: this.machine(nnn);                            break;
			case 0x1: this.pc = nnn;                                break;
			case 0x2: this.call(nnn);                               break;
			case 0x3: if (this.v[x] == nn)        { this.skip(); }  break;
			case 0x4: if (this.v[x] != nn)        { this.skip(); }  break;
			case 0x5: if (this.v[x] == this.v[y]) { this.skip(); }  break;
			case 0x6: this.v[x] = nn;                               break;
			case 0x7: this.v[x] = (this.v[x] + nn) & 0xFF;          break;
			case 0x8: this.math(x, y, n);                           break;
			case 0x9: if (this.v[x] != this.v[y]) { this.skip(); }  break;
			case 0xA: this.i = nnn;                                 break;
			case 0xB: this.jump0(nnn);                              break;
			case 0xC: this.v[x] = (Math.random()*256)&nn;           break;
			case 0xD: this.sprite(this.v[x], this.v[y], n);         break;
			case 0xF: this.misc(x, nn);                             break;
			default: haltBreakpoint("unknown opcode "+o.toString(16).toUppercase());
		}
	}

	this.tick = function() {
		if (this.halted) { return; }
		this.tickCounter++;
		try {
			this.opcode();
		}
		catch(err) {
			console.log("halted: " + err);
			this.halted = true;
		}
	}
}
</script>
<script>"use strict";

////////////////////////////////////
//
//   Emulator Execution
//
////////////////////////////////////

//must be set > 0
var scaleFactor = 5;
//dom id for canvas element
var renderTarget = "target";

const optionFlags = [
	"tickrate",
	"fillColor",
	"fillColor2",
	"blendColor",
	"backgroundColor",
	"buzzColor",
	"quietColor",
	"shiftQuirks",
	"loadStoreQuirks",
	"vfOrderQuirks",
	"clipQuirks",
	"vBlankQuirks",
	"jumpQuirks",
	"screenRotation",
	"maxSize",
	"touchInputMode",
	"logicQuirks",
	"fontStyle",
]
function unpackOptions(emulator, options) {
	optionFlags.forEach(x => { if (x in options) emulator[x] = options[x] })
	if (options["enableXO"]) emulator.maxSize = 65024 // legacy option
}
function packOptions(emulator) {
	const r = {}
	optionFlags.forEach(x => r[x] = emulator[x])
	return r
}

function setRenderTarget(scale, canvas) {
	scaleFactor = scale;
	renderTarget = canvas;
	var c = document.getElementById(canvas);

	// Remove any existing previous delta frame so first frame is always drawn:
	c.last = undefined;

	var w  = scaleFactor * 128;
	var h  = scaleFactor *  64;

	if (emulator.screenRotation == 90 || emulator.screenRotation == 270) {
		c.width  = h;
		c.height = w;
	}
	else {
		c.width  = w;
		c.height = h;
	}
}

function setTransform(emulator, g) {
	g.setTransform(1, 0, 0, 1, 0, 0);
	var x = scaleFactor * 128;
	var y = scaleFactor *  64;
	switch(emulator.screenRotation) {
		case 90:
			g.rotate(0.5 * Math.PI);
			g.translate(0, -y);
			break;
		case 180:
			g.rotate(1.0 * Math.PI);
			g.translate(-x, -y);
			break;
		case 270:
			g.rotate(1.5 * Math.PI);
			g.translate(-x, 0);
			break;
		default:
			console.assert(emulator.screenRotation === 0, 'Screen rotation not set to 0, 90, 180, or 270. Treating as 0.')
	}
}


function arrayEqual(a, b) {
	var length = a.length;
	if (length !== b.length) { return false; }
	for (var i = 0; i < length; i++) {
		if (a[i] !== b[i]) { return false; }
	}
	return true;
}

function getColor(id) {
	switch(id) {
		case 0: return emulator.backgroundColor;
		case 1: return emulator.fillColor;
		case 2: return emulator.fillColor2;
		case 3: return emulator.blendColor;
	}
	throw "invalid color: " + id;
}

function renderDisplay(emulator) {
	var c = document.getElementById(renderTarget);

	// Canvas rendering can be expensive. Exit out early if nothing has changed.
	var colors = [emulator.backgroundColor, emulator.fillColor, emulator.fillColor2, emulator.blendColor];
	if (c.last !== undefined) {
		if (arrayEqual(c.last.p[0], emulator.p[0]) && arrayEqual(c.last.p[1], emulator.p[1])
				&& arrayEqual(c.last.colors, colors)) {
			return;
		}
		if (c.last.hires !== emulator.hires)
			c.last = undefined;  // full redraw when switching resolution
	}
	var g = c.getContext("2d");
	setTransform(emulator, g);
	var w      = emulator.hires ? 128         : 64;
	var h      = emulator.hires ? 64          : 32;
	var size   = emulator.hires ? scaleFactor : scaleFactor*2;
	var lastPixels = c.last !== undefined? c.last.p: [[], []]

	g.scale(size, size)
	var z = 0;
	for(var y = 0; y < h; ++y) {
		for(var x = 0; x < w; ++x, ++z) {
			var oldColorIdx = lastPixels[0][z] + (lastPixels[1][z] << 1);
			var colorIdx = emulator.p[0][z] + (emulator.p[1][z] << 1);
			if (oldColorIdx !== colorIdx) {
				g.fillStyle = getColor(colorIdx);
				g.fillRect(x, y, 1, 1);
			}
		}
	}
	g.scale(1, 1) //restore scale to 1,1 just in case

	c.last = {
		colors: colors,
		p: [emulator.p[0].slice(), emulator.p[1].slice()],
		hires: emulator.hires,
	};
}

////////////////////////////////////
//
//   Audio Playback
//
////////////////////////////////////

var audio;
var audioNode;
var audioSource;
var audioData;

var AudioBuffer = function(buffer, duration) {
	if (!(this instanceof AudioBuffer)) {
		return new AudioBuffer(buffer, duration);
	}

	this.pointer = 0;
	this.buffer = buffer;
	this.duration = duration;
}

AudioBuffer.prototype.write = function(buffer, index, size) {
	size = Math.max(0, Math.min(size, this.duration))
	if (!size) { return size; }

	this.duration -= size;
	var bufferSize = this.buffer.length;
	var end = index + size;

	for(var i = index; i < end; ++i) {
		buffer[i] = this.buffer[this.pointer++];
		this.pointer %= bufferSize;
	}

	return size;
}

AudioBuffer.prototype.dequeue = function(duration) {
	this.duration -= duration;
}

var FREQ = 4000;
var TIMER_FREQ = 60;
var SAMPLES = 16;
var BUFFER_SIZE = SAMPLES * 8


function audioEnable() {
	// this will only work if called directly from a user-generated input handler:
	if (audio && audio.state == 'suspended') audio.resume()
}

function audioSetup() {
	if (!audio) {
		if (typeof AudioContext !== 'undefined') {
			audio = new AudioContext();
		}
		else if (typeof webkitAudioContext !== 'undefined') {
			audio = new webkitAudioContext();
		}
	}
	audioEnable()
	if (audio && !audioNode) {
		audioNode = audio.createScriptProcessor(4096, 1, 1);
		audioNode.onaudioprocess = function(audioProcessingEvent) {
			var outputBuffer = audioProcessingEvent.outputBuffer;
			var outputData = outputBuffer.getChannelData(0);
			var samples_n = outputBuffer.length;

			var index = 0;
			while(audioData.length && index < samples_n) {
				var size = samples_n - index;
				var written = audioData[0].write(outputData, index, size);
				index += written;
				if (written < size) {
					audioData.shift();
				}
			}

			while(index < samples_n) {
				outputData[index++] = 0;
			}
			//the last one can be long sound with high value of buzzer, so always keep it
			if (audioData.length > 1) {
				var audioDataSize = 0;
				var audioBufferSize = audioNode.bufferSize;
				audioData.forEach(function(buffer) { audioDataSize += buffer.duration; })
				while(audioDataSize > audioBufferSize && audioData.length > 1) {
					audioDataSize -= audioData.shift().duration;
				}
			}
		}
		audioData = [];
		audioNode.connect(audio.destination);
		return true;
	}
	if (audio && audioNode) { return true; }
	return false;
}

function stopAudio() {
	if (!audio) { return; }
	if (audioNode) {
		audioNode.disconnect();
		audioNode = null;
	}
	audioData = [];
}

var VOLUME = 0.25;

function playPattern(soundLength, buffer, remainingTicks) {
	if (!audio) { return; }
	audioEnable()

	var samples = Math.floor(BUFFER_SIZE * audio.sampleRate / FREQ);
	var audioBuffer = new Array(samples);
	if (remainingTicks && audioData.length > 0) {
		audioData[audioData.length - 1].dequeue(Math.floor(remainingTicks * audio.sampleRate / TIMER_FREQ));
	}

	for(var i = 0; i < samples; ++i) {
		var srcIndex = Math.floor(i * FREQ / audio.sampleRate);
		var cell = srcIndex >> 3;
		var bit = srcIndex & 7;
		audioBuffer[i] = (buffer[srcIndex >> 3] & (0x80 >> bit)) ? VOLUME: 0;
	}
	audioData.push(new AudioBuffer(audioBuffer, Math.floor(soundLength * audio.sampleRate / TIMER_FREQ)));
}

function escapeHtml(str) {
    var div = document.createElement('div');
    div.appendChild(document.createTextNode(str));
    return div.innerHTML;
}
</script>
<script>/**
* Adaptive Input
**/

const ael = (element, event, listener) => element.addEventListener   (event, listener, { passive:false })
const rel = (element, event, listener) => element.removeEventListener(event, listener, { passive:false })
const pd  = event => (event.preventDefault(),event.stopPropagation())

const VIP_HEX  = '123c456d789ea0bf'.split('')
const VIP_KEYS = VIP_HEX.map(x => parseInt(x,16))

const GAMEPAD_STYLES = `
.gamepad{
  position:absolute;
  top:10%;
  left:0px;
  width:100%;
  height:90%;
  opacity:0.3;
  user-select: none;
  -webkit-user-select: none;
}
.gamepad .dpad{
  position:absolute;
  bottom: 50px;
  left:   50px;
  width:  250px;
  height: 250px;
  background: gray;
  border-radius: 50%;
  overflow:hidden;
}
.gamepad .stick{
  display:none;
  position:absolute;
  border-radius: 50%;
  width:100px;
  height:100px;
  margin-left:-50px;
  margin-top:-50px;
}
.gamepad .buttons{
  position:absolute;
  bottom: 50px;
  right:  50px;
  width:  250px;
  height: 250px;
}
.gamepad .gamebutton{
  position:absolute;
  width:  125px;
  height: 125px;
  background:gray;
  border-radius:50%;
  overflow:hidden;
  line-height: 125px;
  font-size:50px;
  font-weight:bold;
  color:darkgray;
  text-align:center;
}
.gamepad .dpad.active .stick {display:block;background:#444}
.gamepad .gamebutton.active{background:#444;}
.gamepad .gamebutton.b{left:0;bottom:0;}
.gamepad .gamebutton.a{right:0;top:0;}
`
const VIP_STYLES = `
.vip-pad {display:flex;flex-direction:column;align-items:center;z-index:2000;}
.vip-pad .keypad {display:flex;flex-direction:column;margin-top:10px;}
.vip-pad .keypad>div {display:flex;flex-direction:row;}
.vip-pad .keypad>div>div {
  -webkit-user-select: none;
  user-select: none;
  background:gray;
  width: 100px;
  height: 51px;
  display: flex;
  justify-content: center;
  align-items: center;
  margin: 1px;
}
.vip-pad .keypad>div>div:active,
.vip-pad .keypad>div>div.active {background:black; border:1px solid white;margin:0px;}
`

const INPUT_MODULES = {
  /**
  * An invisible set of gesture recognizers,
  * giving directional input and an action for taps.
  **/
  swipe: {
    install: (screen,up,down,options) => {

      let vdirs      = []
      let direction  = { i:null, sx:0, sy:0, lx:0, ly:0 }
      let action1    = {}
      let taptimeout = null

      const updateStick = _ => {
        // find the relative position of the stick to its starting point
        const cx = direction.lx - direction.sx
        const cy = direction.ly - direction.sy

        // update the virtual direction buttons
        let t = []
        const DEAD_ZONE = 30
        if (Math.abs(cx) > DEAD_ZONE) t.push(cx < 0 ? options.left : options.right)
        if (Math.abs(cy) > DEAD_ZONE) t.push(cy < 0 ? options.up   : options.down)
        vdirs.forEach(x => (t    .indexOf(x)<0) && up  (x)) // clear keys no longer held
        t    .forEach(x => (vdirs.indexOf(x)<0) && down(x)) // push keys that were not held before
        vdirs = t
      }
      const tapDown= i => {
        if (Object.keys(action1).length == 0) down(options.action1)
        action1[i] = true
        if (i == direction.i) { direction = { i:null, sx:0, sy:0, lx:0, ly:0 } }
        taptimeout = null
      }
      const start = e => {
        const t = e.touches[0]
        const i = t.identifier
        // a single-touch is either directional or a tap...
        if (direction.i != null) {
          tapDown(i)
        }
        else {
          direction.i  = i
          direction.sx = t.clientX
          direction.sy = t.clientY
          direction.lx = t.clientX
          direction.ly = t.clientY
          taptimeout = setTimeout(_ => tapDown(i), 100)
        }
        updateStick(),pd(e)
      }
      const move = e => {
        for(let z = 0; z < e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i == direction.i) {
            if (taptimeout != null) { clearTimeout(taptimeout); taptimeout = null }
            direction.lx = t.clientX
            direction.ly = t.clientY
          }
        }
        updateStick(),pd(e)
      }
      const end = e => {
        let r1 = false
        for(let z = 0; z < e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i == direction.i) {
            if (taptimeout != null) {
              // cancel a short tap
              clearTimeout(taptimeout); taptimeout = null
              down(options.action1)
              setTimeout(_ => up(options.action1), 50)
            }
            direction = { i:null, sx:0, sy:0, lx:0, ly:0 }
          }
          if (i in action1) {
            delete action1[i]
            r1=true
          }
        }
        if (r1 && Object.keys(action1).length == 0) up(options.action1)
        updateStick(),pd(e)
      }
      ael(screen, 'touchstart', start)
      ael(screen, 'touchmove',  move)
      ael(screen, 'touchend',   end)
      screen.uninstallSwipe = _ => {
        rel(screen, 'touchstart', start)
        rel(screen, 'touchmove',  move)
        rel(screen, 'touchend',   end)
      }
    },
    remove: (screen) => {
      screen.uninstallSwipe()
      delete screen.uninstallSwipe
    }
  },

  /**
  * A virtual gamepad overlay with two remappable action keys.
  **/
  gamepad: {
    install: (screen,up,down,options) => {
      // build the UI
      if (document.querySelector('.gamepad')) return
      const root = document.createElement('div')
      root.classList.add('gamepad')
      root.innerHTML = `
      <div class='dpad'><div class='stick'></div></div>
      <div class='buttons'><div class='gamebutton b'>B</div><div class='gamebutton a'>A</div></div>
      <style>${GAMEPAD_STYLES}</style>`
      screen.parentElement.append(root)

      let vdirs      = []
      let directions = {}
      let buttons    = {}
      const pad   = document.querySelector('.gamepad .dpad')
      const stick = document.querySelector('.gamepad .dpad .stick')
      const a     = document.querySelector('.gamepad .gamebutton.a')
      const b     = document.querySelector('.gamepad .gamebutton.b')

      const updateStick = _ => {
        // find centroid of d-pad touchpoints ({0,0} if no touchpoints)
        const touches = Object.values(directions)
        let cx = 0, cy = 0, r = pad.getBoundingClientRect(), sr = stick.getBoundingClientRect()
        touches.forEach(t => (cx+=t.x, cy+=t.y))
        cx /= touches.length,         cy /= touches.length
        cx -= (r.left + (r.width/2)), cy -= (r.top + (r.height/2))

        // position the virtual stick, clamped within dpad
        const ca = Math.atan2(cy, cx)
        const cd = Math.min(Math.sqrt(cx*cx + cy*cy), (r.width/2)-(sr.width/2))
        stick.style.left = ((Math.cos(ca)*cd)+(r.width /2)|0)+'px'
        stick.style.top  = ((Math.sin(ca)*cd)+(r.height/2)|0)+'px'

        // update the virtual direction buttons
        let t = []
        const DEAD_ZONE = 30
        if (Math.abs(cx) > DEAD_ZONE) t.push(cx < 0 ? options.left : options.right)
        if (Math.abs(cy) > DEAD_ZONE) t.push(cy < 0 ? options.up   : options.down)
        vdirs.forEach(x => (t    .indexOf(x)<0) && up  (x)) // clear keys no longer held
        t    .forEach(x => (vdirs.indexOf(x)<0) && down(x)) // push keys that were not held before
        vdirs = t
      }

      const start = e => {
        for(let z = 0; z<e.touches.length; z++) {
          const t = e.touches[z]
          const i = t.identifier
          if (t.target == a) {
            t.target.classList.add('active')
            buttons[i]=options.action1
            down(options.action1)
          }
          if (t.target == b) {
            t.target.classList.add('active')
            buttons[i]=options.action2
            down(options.action2)
          }
          if (t.target == pad) {
            t.target.classList.add('active')
            directions[i]={x:t.clientX, y:t.clientY}
          }
        }
        updateStick(),pd(e)
      }
      const move = e => {
        for(let z = 0; z<e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i in directions) directions[i]={x:t.clientX, y:t.clientY}
        }
        updateStick(),pd(e)
      }
      const end = e => {
        for(let z = 0; z<e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (i in buttons) {
            t.target.classList.remove('active')
            up(buttons[i])
            delete buttons[i]
          }
          if (i in directions) {
            t.target.classList.remove('active')
            delete directions[i]
          }
        }
        updateStick(),pd(e)
      }

      ael(a,   'touchstart', start)
      ael(a,   'touchend',   end  )
      ael(b,   'touchstart', start)
      ael(b,   'touchend',   end  )
      ael(pad, 'touchstart', start)
      ael(pad, 'touchmove',  move )
      ael(pad, 'touchend',   end  )
    },
    remove: (screen) => {
      document.querySelector('.gamepad').remove()
    },
  },

  /**
  * Treat the entire screen, or a centered square region, as invisible buttons,
  * mapped out in the order of the VIP hex keypad.
  **/
  seg16: {
    install: (screen,up,down,options) => {
      const tmap = {}
      const pointToKey = touch => {
        // poll this for each point, as it may vary over time,
        // and experimentally it's never right initially...
        const r = screen.getBoundingClientRect()
        if (options.mode == 'center') {
          if (r.width > r.height) { r.x += (r.width - r.height)/2; r.width = r.height }
          else                    { r.y += (r.height - r.width)/2; r.height = r.width }
        }
        const x = touch.clientX - r.x
        const y = touch.clientY - r.y
        if (x < 0 || x > r.width || y < 0 || y > r.height) return null
        const tx = Math.floor(x / (r.width /4))
        const ty = Math.floor(y / (r.height/4))
        return VIP_KEYS[tx + (4 * ty)]
      }
      const start = e => {
        for(let z=0; z<e.touches.length; z++) {
          const i = e.touches[z].identifier
          const k = pointToKey(e.touches[z])
          if (k != null) down(k)
          tmap[i]=k
        }
        pd(e)
      }
      const move = e => {
        for(let z=0; z<e.touches.length; z++) {
          const i = e.touches[z].identifier
          const k = pointToKey(e.touches[z])
          if (tmap[i] == k) continue       // same cell, nothing to do.
          if (tmap[i] != null) up(tmap[i]) // release old key, if any
          if (k != null)       down(k)     // press new key, if any
          tmap[i]=k
        }
        pd(e)
      }
      const end = e => {
        for(let z=0; z<e.changedTouches.length; z++) {
          const i = e.changedTouches[z].identifier
          const k = pointToKey(e.changedTouches[z])
          if (tmap[i] != null) up(tmap[i])
          tmap[i]=null
        }
        pd(e)
      }
      ael(screen, 'touchstart', start)
      ael(screen, 'touchmove',  move )
      ael(screen, 'touchend',   end  )
      screen.uninstallSeg16 = _ => {
        rel(screen, 'touchstart', start)
        rel(screen, 'touchmove',  move )
        rel(screen, 'touchend',   end  )
      }
    },
    remove:  (screen) => {
      screen.uninstallSeg16()
      delete screen.uninstallSeg16
    },
  },

  /**
  * Provide a visible 4x4 representation of the VIP hex keypad.
  **/
  vip: {
    install: (screen,up,down,options) => {
      if (document.querySelector('.vip-pad')) return
      const root = document.createElement('div')
      root.classList.add('vip-pad')
      root.innerHTML = `<div class='keypad'>
        ${[0,1,2,3].map(r=>`<div>${[0,1,2,3].map(c=>`<div>${VIP_HEX[c+(r*4)].toUpperCase()}</div>`).join('')}</div>`).join('')}
      </div>
      <style>${VIP_STYLES}</style>`
      if (screen.parentElement == document.body) { screen.parentElement.append(root) }
      else { screen.parentElement.parentElement.append(root) }
      const buttons = []
      document.querySelectorAll('.vip-pad .keypad>div>div').forEach(x=>buttons.push(x)) // make an actual Array
      const held = {}
      const start = e => {
        for(let z=0; z<e.touches.length; z++) {
          const t = e.touches[z]
          const i = t.identifier
          const k = VIP_KEYS[buttons.indexOf(t.target)]
          t.target.classList.add('active')
          down(k)
          held[i]=k
        }
        pd(e)
      }
      const end = e => {
        for(let z = 0; z<e.changedTouches.length; z++) {
          const t = e.changedTouches[z]
          const i = t.identifier
          if (held[i]) { up(held[i]); delete held[i] }
          t.target.classList.remove('active')
        }
        pd(e)
      }
      buttons.forEach(b => {
        ael(b, 'touchstart', start)
        ael(b, 'touchend',   end  )
      })
    },
    remove:  (screen) => {
      document.querySelector('.vip-pad').remove()
    },
  },
}

let adaptiveControlsInstalled = null

function injectAdaptiveControls(type, screen, keyup, keydown) {
  let options = {
    up:      5,
    down:    8,
    left:    7,
    right:   9,
    action1: 6,
    action2: 4,
    mode:    'center', // or 'fill', used by seg16
  }
  const lookup = vk => Object.keys(keymap[vk])[0]
  const install = _ => {
    rel(screen, 'touchstart', install)
    adaptiveControlsInstalled = type
    INPUT_MODULES[type].install(
      screen,
      key => keyup  ({ key:lookup(key), preventDefault:_=>_ }),
      key => keydown({ key:lookup(key), preventDefault:_=>_ }),
      options
    )
  }
  // uninstall anything that's already there:
  rel(screen, 'touchstart', install)
  if (adaptiveControlsInstalled) INPUT_MODULES[adaptiveControlsInstalled].remove(screen)

  if (type == 'none') return
  if (type == 'seg16fill') { type='seg16'; options.mode='fill' }
  // defer installing adaptive input until we actually see
  // an input event from the user:
  ael(screen, 'touchstart', install)
}
</script>
<body><canvas id='target' width=512 height=256></canvas></body>
<style>body{margin:0px;display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;}</style>
<script>
const emulator = new Emulator()
unpackOptions(emulator, data.options)
setRenderTarget(data.options.displayScale || 4, 'target')
emulator.init({rom:data.rom})
emulator.importFlags = _ => getPref('octoFlagRegisters')
emulator.exportFlags = f => setPref('octoFlagRegisters',f)
emulator.buzzTrigger = (ticks,rest)=> playPattern(ticks, emulator.pattern, rest)
const kd = e=>{
	if (!audio) audioSetup()
	if (!(e.key in emulator.keys)) emulator.keys[e.key]=true
	e.preventDefault()
}
const ku = e=>{
	if (e.key in emulator.keys) delete emulator.keys[e.key]
	if (!emulator.waiting) return
	const kindex = keymapInverse[e.key]
	if (kindex != undefined) {
		emulator.waiting = false
		emulator.v[emulator.waitReg] = kindex
	}
	e.preventDefault()
}
window.addEventListener('keydown',kd,false)
window.addEventListener('keyup',ku,false)
intervalHandle = setInterval(_=>{
	if (emulator.halted) return
	for(var z = 0; (z<emulator.tickrate) && (!emulator.waiting); z++) emulator.tick()
	if (emulator.dt > 0) emulator.dt--
	if (emulator.st > 0) emulator.st--
	renderDisplay(emulator)
	document.body.style.backgroundColor = emulator.st?emulator.buzzColor:emulator.quietColor
}, 1000/60)

injectAdaptiveControls(emulator.touchInputMode,document.getElementById('target'),ku,kd)
</script>
